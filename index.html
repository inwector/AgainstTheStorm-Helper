<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Against the Storm Blueprint Optimizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

            .header h1 {
                font-size: 2.5rem;
                margin-bottom: 10px;
                background: linear-gradient(45deg, #ffd700, #ff6b35);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
            }

            .header p {
                font-size: 1.1rem;
                opacity: 0.8;
            }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .section-title {
            font-size: 1.4rem;
            margin-bottom: 20px;
            color: #ffd700;
        }

        .input-group {
            margin-bottom: 20px;
        }

            .input-group label {
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: #e0e0e0;
            }

        select, input[type="checkbox"] {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            padding: 10px;
            width: 100%;
            font-size: 14px;
        }

            select:focus {
                outline: none;
                border-color: #ffd700;
                box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.3);
            }

        .species-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .species-item {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            cursor: pointer;
        }

            .species-item:hover {
                background: rgba(255, 255, 255, 0.1);
            }

            .species-item.selected {
                border-color: #ffd700;
                background: rgba(255, 215, 0, 0.2);
            }

            .species-item input[type="checkbox"] {
                width: auto;
                margin-right: 8px;
            }

        .buildings-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .building-item {
            display: flex;
            align-items: center;
            padding: 0px;
            font-size: 14px;
        }

            .building-item input[type="checkbox"] {
                width: auto;
                margin-right: 8px;
            }

        .blueprint-options {
            margin-top: 20px;
        }

        .blueprint-option {
            margin-bottom: 15px;
        }

            .blueprint-option label {
                font-weight: 600;
                color: #ffd700;
            }

        .calculate-btn {
            background: linear-gradient(45deg, #ff6b35, #ffd700);
            border: none;
            border-radius: 10px;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: 600;
            color: #1a1a2e;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 20px;
        }

            .calculate-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 20px rgba(255, 107, 53, 0.3);
            }

            .calculate-btn:disabled {
                opacity: 0.6;
                cursor: not-allowed;
                transform: none;
            }

        .results {
            min-height: 200px;
        }

        .loading {
            text-align: center;
            opacity: 0.7;
            font-style: italic;
            padding: 40px 20px;
        }

        .recommendation {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

            .recommendation.best {
                border-color: #ffd700;
                background: rgba(255, 215, 0, 0.2);
            }

            .recommendation h3 {
                color: #ffd700;
                margin-bottom: 10px;
            }

        .score {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

            .score.best {
                color: #00ff88;
            }

            .score.good {
                color: #ffd700;
            }

            .score.poor {
                color: #ff6b35;
            }

        .reasoning {
            font-size: 0.9rem;
            opacity: 0.9;
            line-height: 1.4;
        }

        .error {
            background: rgba(255, 107, 53, 0.2);
            border: 1px solid rgba(255, 107, 53, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            color: #ff6b35;
        }

        .species-counter {
            font-size: 0.9rem;
            color: #ffd700;
            margin-top: 5px;
        }

        .data-status {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

            .data-status.loaded {
                border-left: 4px solid #00ff88;
            }

            .data-status.error {
                border-left: 4px solid #ff6b35;
            }

        .details {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            font-size: 0.8rem;
        }

        .rainwater-selection {
            display: flex;
            gap: 12px;
            margin-top: 6px;
        }

        .rainwater-option {
            display: flex;
            align-items: center;
            gap: 6px;
            background-color: #26293a;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
        }

            .rainwater-option:hover {
                background-color: #16213e;
            }

            .rainwater-option input[type="checkbox"] {
                accent-color: #4a90e2; /* Nice blue checkmark */
            }

        .info-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #007bff;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            line-height: 16px;
            cursor: help;
            margin-left: 5px;
            position: relative;
        }

            .info-icon::before {
                content: "i";
                font-family: Arial, sans-serif;
            }

        .footer-social {
            text-align: center;
            padding: 30px 0;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 40px;
        }

            .footer-social h3 {
                color: #ffd700;
                margin-bottom: 20px;
                font-size: 1.4rem;
            }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .footer-link {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            color: #fff;
            transition: all 0.3s ease;
            padding: 20px 15px;
            border-radius: 15px;
            min-width: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

            .footer-link:hover {
                background: rgba(255,255,255,0.15);
                transform: translateY(-5px);
                box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            }

            .footer-link .icon {
                font-size: 2.5rem;
                margin-bottom: 12px;
                transition: transform 0.3s ease;
            }

            .footer-link:hover .icon {
                transform: scale(1.1);
            }

            .footer-link .platform {
                font-weight: 600;
                margin-bottom: 4px;
                font-size: 1.1rem;
            }

            .footer-link .handle {
                font-size: 0.85rem;
                opacity: 0.8;
            }

            /* Platform-specific styling */
            .footer-link.youtube .icon {
                color: #ff0000;
            }

            .footer-link.youtube:hover {
                border-color: #ff0000;
                box-shadow: 0 10px 25px rgba(255, 0, 0, 0.2);
            }

            .footer-link.discord .icon {
                color: #5865f2;
            }

            .footer-link.discord:hover {
                border-color: #5865f2;
                box-shadow: 0 10px 25px rgba(88, 101, 242, 0.2);
            }

            .footer-link.twitch .icon {
                color: #9146ff;
            }

            .footer-link.twitch:hover {
                border-color: #9146ff;
                box-shadow: 0 10px 25px rgba(145, 70, 255, 0.2);
            }

            .footer-link.kick .icon {
                color: #53fc18;
            }

            .footer-link.kick:hover {
                border-color: #53fc18;
                box-shadow: 0 10px 25px rgba(83, 252, 24, 0.2);
            }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .footer-links {
                gap: 20px;
            }

            .footer-link {
                min-width: 100px;
                padding: 15px 10px;
            }

                .footer-link .icon {
                    font-size: 2rem;
                    margin-bottom: 8px;
                }

                .footer-link .platform {
                    font-size: 1rem;
                }

                .footer-link .handle {
                    font-size: 0.8rem;
                }
        }

        @media (max-width: 480px) {
            .footer-links {
                gap: 15px;
                justify-content: space-evenly;
            }

            .footer-link {
                min-width: 80px;
                padding: 12px 8px;
            }

            .footer-social h3 {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Inwector's Against the Storm Blueprint Optimizer</h1>
            <p>Choose the best blueprints for your settlement based on biome, species, and current buildings</p>
        </div>

        <div id="data-status" class="data-status">
            📡 Loading game data...
        </div>

        <div class="main-content">
            <div class="section">
                <h2 class="section-title">🏗️ Settlement Configuration</h2>

                <div class="input-group">
                    <label for="biome-select">Biome:</label>
                    <select id="biome-select">
                        <option value="">Select a biome...</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>Species (select exactly 3):</label>
                    <div class="species-selection" id="species-selection">
                        <!-- Species will be populated here -->
                    </div>
                    <div class="species-counter" id="species-counter">Selected: 0/3</div>
                </div>

                <div class="input-group">
                    <label>Available Rainwater Types:</label>
                    <div class="rainwater-selection" id="rainwater-selection">
                        <label class="rainwater-option">
                            <input type="checkbox" value="clearance">
                            <span>💧 Clearance</span>
                        </label>
                        <label class="rainwater-option">
                            <input type="checkbox" value="drizzle">
                            <span>🌦️ Drizzle</span>
                        </label>
                        <label class="rainwater-option">
                            <input type="checkbox" value="storm">
                            <span>⛈️ Storm</span>
                        </label>
                    </div>
                </div>

                <div class="input-group" style="display: flex; align-items: center; gap: 10px; margin-bottom:2px">
                    <label for="building-filter">Current Buildings:</label>
                    <input type="text" id="building-filter" style="margin-bottom:6px"  placeholder="Filter buildings...">
                </div>
                <div class="buildings-list" id="current-buildings">
                    <!-- Buildings will be populated here -->
                </div>

                <div class="blueprint-options">
                    <label>
                        Blueprint Options:
                        <span class="info-icon" title="If you pick no blueprints, all buildings will be considered as picks"></span>
                    </label>
                    <div class="blueprint-option">
                        <label for="blueprint-1">Option 1:</label>
                        <select id="blueprint-1">
                            <option value="">Select a building...</option>
                        </select>
                    </div>
                    <div class="blueprint-option">
                        <label for="blueprint-2">Option 2:</label>
                        <select id="blueprint-2">
                            <option value="">Select a building...</option>
                        </select>
                    </div>
                    <div class="blueprint-option">
                        <label for="blueprint-3">Option 3:</label>
                        <select id="blueprint-3">
                            <option value="">Select a building...</option>
                        </select>
                    </div>
                    <div class="blueprint-option">
                        <label for="blueprint-4">Option 4:</label>
                        <select id="blueprint-4">
                            <option value="">Select a building...</option>
                        </select>
                    </div>
                </div>

                <button class="calculate-btn" id="calculate-btn" onclick="calculateOptimalBlueprint()">
                    🧮 Calculate Best Choice
                </button>
            </div>

            <div class="section">
                <h2 class="section-title">📊 Recommendations</h2>
                <div class="results" id="results">
                    <div class="loading">
                        Configure your settlement and blueprint options, then click "Calculate Best Choice" to see recommendations.
                    </div>
                </div>
            </div>
        </div>
        <div class="footer-social">
            <h3>Connect with Inwector</h3>
            <div class="footer-links">
                <a href="https://youtube.com/@inwector" target="_blank" class="footer-link youtube">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 180"><path fill="#f00" d="M250.346 28.075A32.18 32.18 0 0 0 227.69 5.418C207.824 0 127.87 0 127.87 0S47.912.164 28.046 5.582A32.18 32.18 0 0 0 5.39 28.24c-6.009 35.298-8.34 89.084.165 122.97a32.18 32.18 0 0 0 22.656 22.657c19.866 5.418 99.822 5.418 99.822 5.418s79.955 0 99.82-5.418a32.18 32.18 0 0 0 22.657-22.657c6.338-35.348 8.291-89.1-.164-123.134" /><path fill="#fff" d="m102.421 128.06l66.328-38.418l-66.328-38.418z" /></svg>
                    <div class="platform">YouTube</div>
                    <div class="handle">@inwector</div>
                </a>
                <a href="https://discord.gg/dxXqAceNaD" target="_blank" class="footer-link discord">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 199"><path fill="#5865f2" d="M216.856 16.597A208.5 208.5 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046q-29.538-4.442-58.533 0c-1.832-4.4-4.55-9.933-6.846-14.046a207.8 207.8 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161 161 0 0 0 79.735 175.3a136.4 136.4 0 0 1-21.846-10.632a109 109 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a132 132 0 0 0 5.355 4.237a136 136 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848c21.142-6.58 42.646-16.637 64.815-33.213c5.316-56.288-9.08-105.09-38.056-148.36M85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2s23.236 11.804 23.015 26.2c.02 14.375-10.148 26.18-23.015 26.18m85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2c0 14.375-10.148 26.18-23.015 26.18"/></svg>
                    <div class="platform">Discord</div>
                    <div class="handle">Join Server</div>
                </a>
                <a href="https://twitch.tv/inwector" target="_blank" class="footer-link twitch">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 268"><path fill="#5a3e85" d="M17.458 0L0 46.556v186.201h63.983v34.934h34.931l34.898-34.934h52.36L256 162.954V0zm23.259 23.263H232.73v128.029l-40.739 40.741H128L93.113 226.92v-34.886H40.717zm64.008 116.405H128V69.844h-23.275zm63.997 0h23.27V69.844h-23.27z" /></svg>
                    <div class="platform">Twitch</div>
                    <div class="handle">@inwector</div>
                </a>
                <a href="https://kick.com/inwector" target="_blank" class="footer-link kick">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 290"><path fill="#05ce78" d="m209.302 144.583l26.28-26.105c27.224-27.042 27.224-71.087 0-98.129s-71.564-27.043-98.788 0l-9.569 9.504C114.557 11.781 93.667 0 69.812 0C31.267 0 0 31.059 0 69.346v150.34c0 38.287 31.267 69.346 69.812 69.346c23.855 0 44.745-11.781 57.413-29.854l9.569 9.505c27.224 27.043 71.564 27.043 98.788 0s27.224-71.086 0-98.129z" /></svg>
                    <div class="platform">Kick</div>
                    <div class="handle">@inwector</div>
                </a>
            </div>
        </div>
    </div>

    <script>

        const buildingFilter = document.getElementById('building-filter');
        const buildingsList = document.getElementById('current-buildings');

        buildingFilter.addEventListener('input', () => {
            const filterText = buildingFilter.value.toLowerCase();
            const buildingItems = buildingsList.querySelectorAll('.building-item');

            buildingItems.forEach(item => {
                const label = item.querySelector('label').textContent.toLowerCase();
                if (label.includes(filterText)) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });
        });


        // Global data containers
        let gameData = {
            biomes: {},
            species: {},
            buildings: {},
            recipes: {}
        };

        let dataLoadStatus = {
            biomes: false,
            species: false,
            buildings: false,
            recipes: false
        };

        // Species icons mapping
        const speciesIcons = {
            humans: '👥',
            beavers: '🐿️',
            lizards: '🦎',
            harpies: '🦅',
            foxes: '🦊',
            frogs: '🐸',
            bats: '🦇'
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function () {
            loadGameData();
            // Add this new line with a small delay to ensure UI is ready
            setTimeout(() => {
                initializeBuildingSelectionHandlers();
            }, 100);
        });

        // Load all game data from JSON files
        async function loadGameData() {
            const dataStatus = document.getElementById('data-status');

            try {
                const files = {
                    biomes: 'js/data/biomes.json',
                    species: 'js/data/species.json',
                    buildings: 'js/data/buildings.json',
                    recipes: 'js/data/recipes.json'
                };

                const results = await Promise.allSettled(
                    Object.values(files).map(loadJSON)
                );

                // Store data globally + log results
                let i = 0;
                for (const key of Object.keys(files)) {
                    const result = results[i];
                    if (result.status === 'fulfilled') {
                        gameData[key] = result.value;
                        console.log(`✅ ${files[key]} loaded`, result.value);
                    } else {
                        console.error(`❌ ${files[key]} failed`, result.reason);
                        gameData[key] = null; // or {}
                    }
                    i++;
                }


                // Mark all as loaded
                Object.keys(dataLoadStatus).forEach(key => dataLoadStatus[key] = true);

                // Update status
                dataStatus.textContent = '✅ Game data loaded successfully. Tuned to patch 1.9.';
                dataStatus.className = 'data-status loaded';

                // Initialize UI components
                initializeUI();

            } catch (error) {
                console.error('Error loading game data:', error);
                dataStatus.textContent = `❌ Error loading game data: ${error.message}`;
                dataStatus.className = 'data-status error';
            }
        }

        // Helper function to load JSON files
        async function loadJSON(filename) {
            const response = await fetch(filename);
            if (!response.ok) {
                throw new Error(`Failed to load ${filename}: ${response.statusText}`);
            }
            return await response.json();
        }

        // Initialize UI components after data is loaded
        function initializeUI() {
            populateBiomes();
            populateSpecies();
            populateBuildings();
            populateBlueprintOptions();
            initializeSpeciesSelection();
            updateCalculateButton();
        }

        // Populate biome dropdown
        function populateBiomes() {
            const biomeSelect = document.getElementById('biome-select');

            Object.entries(gameData.biomes).forEach(([key, biome]) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = biome.name;
                biomeSelect.appendChild(option);
            });
        }

        // Populate species selection
        function populateSpecies() {
            const speciesContainer = document.getElementById('species-selection');
            speciesContainer.innerHTML = '';

            Object.entries(gameData.species).forEach(([key, speciesData]) => {
                const speciesItem = document.createElement('div');
                speciesItem.className = 'species-item';
                speciesItem.setAttribute('data-species', key);

                const icon = speciesIcons[key] || '👥';

                speciesItem.innerHTML = `
                                    <input type="checkbox" id="${key}" value="${key}">
                                    <span for="${key}">${icon} ${speciesData.name}</span>
                                `;

                speciesContainer.appendChild(speciesItem);
            });
        }

        function populateBuildings() {
            const buildingsContainer = document.getElementById('current-buildings');
            buildingsContainer.innerHTML = '';

            // 1. Get selected species from checkboxes
            const selectedSpecies = Array.from(
                document.querySelectorAll('#species-selection input[type="checkbox"]:checked')
            ).map(cb => cb.value);

            // Priority building keys
            const priorityBuildings = ['field_kitchen', 'makeshift_post', 'crude_workstation'];

            // Function to render a single building checkbox
            function renderBuilding(key, building, preselect = false) {
                const buildingItem = document.createElement('div');
                buildingItem.className = 'building-item';
                buildingItem.setAttribute('data-building-key', key); // Add this line to store the building key
                buildingItem.innerHTML = `
            <input type="checkbox" id="building-${key}" value="${key}" ${preselect ? 'checked' : ''}>
            <label for="building-${key}">${building.name}</label>
        `;
                buildingsContainer.appendChild(buildingItem);
            }

            // 2. First render priority buildings (if they match species filter)
            priorityBuildings.forEach(key => {
                const building = gameData.buildings[key];
                if (!building) return;

                if (
                    building.species_exclusivity &&
                    !selectedSpecies.includes(building.species_exclusivity)
                ) {
                    return; // skip if species doesn't match
                }

                renderBuilding(key, building, true); // always preselect
            });

            // 3. Render all other buildings
            Object.entries(gameData.buildings).forEach(([key, building]) => {
                // Skip priority buildings (already rendered)
                if (priorityBuildings.includes(key)) return;

                // Skip if exclusivity exists and is NOT in selectedSpecies
                if (
                    building.species_exclusivity &&
                    !selectedSpecies.includes(building.species_exclusivity)
                ) {
                    return;
                }

                renderBuilding(key, building);
            });

            // After populating buildings, update blueprint options
            populateBlueprintOptions();
        }


        // Populate blueprint option dropdowns
        function populateBlueprintOptions() {
            const blueprintSelects = ['blueprint-1', 'blueprint-2', 'blueprint-3', 'blueprint-4'];

            // Get excluded buildings
            const excludedBasic = ['field_kitchen', 'makeshift_post', 'crude_workstation'];
            const currentBuildings = getCurrentSelectedBuildings(); // Get currently selected buildings

            blueprintSelects.forEach(selectId => {
                const select = document.getElementById(selectId);
                const currentValue = select.value; // Preserve current selection if still valid

                // Clear existing options except the default
                select.innerHTML = '<option value="">Select a building...</option>';

                Object.entries(gameData.buildings).forEach(([key, building]) => {
                    // Check exclusion criteria
                    const isExcludedBasic = excludedBasic.includes(key);
                    const isCurrentBuilding = currentBuildings.includes(key);
                    const hasHolyHallowed = building.name.includes('Holy') || building.name.includes('Hallowed') || building.name.includes('Flawless');

                    // Only add if not excluded
                    if (!isExcludedBasic && !isCurrentBuilding && !hasHolyHallowed) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = building.name;
                        select.appendChild(option);
                    }
                });

                // Restore previous selection if it's still valid
                if (currentValue && select.querySelector(`option[value="${currentValue}"]`)) {
                    select.value = currentValue;
                }
            });
        }

        // Helper function to get currently selected buildings from the current buildings list
        function getCurrentSelectedBuildings() {
            const selectedBuildings = [];
            const checkedBoxes = document.querySelectorAll('#current-buildings input[type="checkbox"]:checked');

            checkedBoxes.forEach(checkbox => {
                selectedBuildings.push(checkbox.value);
            });

            return selectedBuildings;
        }


        function initializeBuildingSelectionHandlers() {
            const currentBuildingsContainer = document.getElementById('current-buildings');

            // Use event delegation to handle checkbox changes
            currentBuildingsContainer.addEventListener('change', function (event) {
                if (event.target.type === 'checkbox') {
                    // Update blueprint options whenever a building checkbox changes
                    populateBlueprintOptions();
                }
            });
        }


        function initializeSpeciesSelection() {
            const speciesItems = document.querySelectorAll('.species-item');
            const speciesCounter = document.getElementById('species-counter');

            speciesItems.forEach(item => {
                const checkbox = item.querySelector('input[type="checkbox"]');

                item.addEventListener('click', function (e) {
                    if (e.target === checkbox) return;

                    const selectedCount = document.querySelectorAll('.species-item input[type="checkbox"]:checked').length;

                    if (!checkbox.checked && selectedCount >= 3) {
                        return;
                    }

                    checkbox.checked = !checkbox.checked;
                    updateSpeciesSelection();
                });

                checkbox.addEventListener('change', updateSpeciesSelection);
            });

            function updateSpeciesSelection() {
                const selectedCount = document.querySelectorAll('.species-item input[type="checkbox"]:checked').length;
                speciesCounter.textContent = `Selected: ${selectedCount}/3`;

                speciesItems.forEach(item => {
                    const checkbox = item.querySelector('input[type="checkbox"]');
                    if (checkbox.checked) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });

                // Refresh buildings when species selection changes (this affects building exclusivity)
                populateBuildings();
                updateCalculateButton();
            }
        }

        function updateCalculateButton() {
            const biome = document.getElementById('biome-select').value;
            const selectedSpecies = document.querySelectorAll('.species-item input[type="checkbox"]:checked').length;
            const blueprint1 = document.getElementById('blueprint-1').value;
            const blueprint2 = document.getElementById('blueprint-2').value;
            const blueprint3 = document.getElementById('blueprint-3').value;
            const blueprint4 = document.getElementById('blueprint-4').value;

            const calculateBtn = document.getElementById('calculate-btn');
            const dataLoaded = Object.values(dataLoadStatus).every(Boolean);

            calculateBtn.disabled = !dataLoaded || !biome || selectedSpecies !== 3;
        }

        // Add event listeners for form validation
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(() => {
                document.getElementById('biome-select')?.addEventListener('change', updateCalculateButton);
                document.getElementById('blueprint-1')?.addEventListener('change', updateCalculateButton);
                document.getElementById('blueprint-2')?.addEventListener('change', updateCalculateButton);
                document.getElementById('blueprint-3')?.addEventListener('change', updateCalculateButton);
                document.getElementById('blueprint-4')?.addEventListener('change', updateCalculateButton);
            }, 1000);
        });

        // ==========================================
        // MAIN CALCULATION FUNCTION - EDIT THIS!
        // ==========================================

        function calculateOptimalBlueprint() {
            const biome = document.getElementById('biome-select').value;
            const selectedSpecies = Array.from(document.querySelectorAll('.species-item input[type="checkbox"]:checked')).map(cb => cb.value);
            const currentBuildings = Array.from(document.querySelectorAll('#current-buildings input[type="checkbox"]:checked')).map(cb => cb.value);
            const availableRainwater = Array.from(document.querySelectorAll('.rainwater-option input[type="checkbox"]:checked')).map(cb => cb.value);
            let blueprintOptions = [
                document.getElementById('blueprint-1').value,
                document.getElementById('blueprint-2').value,
                document.getElementById('blueprint-3').value,
                document.getElementById('blueprint-4').value
            ].filter(option => option);

            if (blueprintOptions.length === 0) {
                blueprintOptions = Object.keys(gameData.buildings);
            }

            if (!biome || selectedSpecies.length !== 3) {
                showError('Please select a biome and exactly 3 species.');
                return;
            }

            // Calculate scores for each blueprint option
            const results = blueprintOptions.map(blueprint => {
                const analysis = analyzeBlueprint(blueprint, biome, selectedSpecies, currentBuildings, availableRainwater);
                return {
                    building: blueprint,
                    score: analysis.score,
                    reasoning: analysis.reasoning,
                    details: analysis.details
                };
            });

            // Sort by score (highest first)
            results.sort((a, b) => b.score - a.score);
            displayResults(results);
        }

        // ==========================================
        // YOUR ALGORITHM IMPLEMENTATION GOES HERE!
        // ==========================================
        function analyzeBlueprint(buildingKey, biomeKey, selectedSpecies, currentBuildings, availableRainwater) {
            const building = gameData.buildings[buildingKey];
            const biome = gameData.biomes[biomeKey];

            let analysis = {
                score: 0,
                reasoning: [],
                details: {
                    speciesBonus: 0,
                    resourceAvailability: 0,
                    needsFulfillment: 0,
                    productionValue: 0,
                    prerequisiteFulfillment: 0,
                    existingFulfillment: 0,
                    rainwaterBonus: 0,
                    inheritBonus: 0,
                    fertileSoilBonus: 0,
                    fertileUsefulnessScore: 0,
                    isFarmUseless: 0
                }
            };

            if (!building || !biome) {
                analysis.reasoning.push('❌ Missing building or biome data');
                return analysis;
            }

            // Base score
            analysis.score = 0;

            // 1) Exclusivity
            if (building.exclusivity && building.exclusivity !== "") {
                if (!selectedSpecies.includes(building.exclusivity)) {
                    analysis.score = -1000;
                    analysis.details.exclusivityCheck = -1000;
                    analysis.reasoning.push(`❌ Cannot build: Exclusive to ${gameData.species[building.exclusivity]?.name}`);
                    return analysis;
                }
            }

            // 1.1) Houses
            if (building.category == "housing")
                analysis.score = 70;

            // 1.2) Farms
            if (building.category == "farming") {
                // Fertile soil and farms
                const fertileBonus = analyzeFertileSoilBonus(building, biome, currentBuildings);
                analysis.details.fertileSoilBonus = fertileBonus;
                analysis.reasoning.push(`<li>+${fertileBonus}: fertile soil is ${biome.fertile_soil} in ${biome.name}`);
                analysis.score += fertileBonus;
            }

            // 1.3) Do you have a farm while choosing another farm?
            if (building.category == "farming") {
                const farmExistsPoints = isFarmWhileFarmingBuildingExists(building, biome, currentBuildings);
                analysis.details.fertileSoilBonus = farmExistsPoints;
                analysis.reasoning.push(`<li>${farmExistsPoints}: fertile soil can already be used by other buildings`);
                analysis.score += farmExistsPoints;
            }
            

            // 1.4) Farms usefulness
            if (building.category == "farming") {
                // Fertile soil and farms usefulness
                const fertileUsefulnessScore = analyzeFertileSoilUsefulness(building, biome, currentBuildings);
                if (fertileUsefulnessScore != 0) {
                    analysis.details.fertileUsefulnessScore = fertileUsefulnessScore;
                    analysis.reasoning.push(`<li>+${fertileUsefulnessScore} produces useful products for existing buildings`);
                    analysis.score += fertileUsefulnessScore;
                }
            }

            // 1.5) Greenhouses
            if (building.category == "farming") {

                if (building.name == "Clay Pit" && !availableRainwater.includes("clearance")) {
                    analysis.score += -50;
                    analysis.details.isFarmUseless = -50;
                    analysis.reasoning.push(`<li>-50 lacking the required water to produce in this building`);
                }

                if (building.name == "Greenhouse" && !availableRainwater.includes("drizzle")) {
                    analysis.score += -50;
                    analysis.details.isFarmUseless = -50;
                    analysis.reasoning.push(`<li>-50 lacking the required water to produce in this building`);
                }
            }

            // 2) Species specialization bonus (guard both sides)
            selectedSpecies.forEach(speciesKey => {
                const species = gameData.species[speciesKey];

                if (species?.specialization_bonus && Array.isArray(building?.specialization_bonus)) {
                    building.specialization_bonus.forEach(buildingSpec => {
                        if (species.specialization_bonus.includes(buildingSpec)) {
                            analysis.score += 15;
                            analysis.details.speciesBonus += 15;
                            analysis.reasoning.push(`<li>+15: ${species.name} specialize in ${buildingSpec}`);
                        }
                    });
                }
            });

            // 3) Resource availability
            const resourceScore = analyzeResourceAvailability(building, biome);
            analysis.score += resourceScore;
            analysis.details.resourceAvailability = resourceScore;
            if (resourceScore > 0) analysis.reasoning.push(`<li>+${resourceScore}: Resource availability in biome`);
            else if (resourceScore < 0) analysis.reasoning.push(`<li>${resourceScore}: Resource constraints`);

            // 4) Needs fulfillment
            const needsScore = analyzeNeedsFulfillment(building, selectedSpecies);
            analysis.score += needsScore;
            analysis.details.needsFulfillment = needsScore;
            if (needsScore > 0) analysis.reasoning.push(`<li>+${needsScore}: Fulfills species needs`);

            // 4.5) Service fulfillment
            const serviceScore = analyzeServiceFulfillment(building, selectedSpecies);
            analysis.score += serviceScore;
            analysis.details.serviceFulfillment = needsScore;
            if (serviceScore > 0) analysis.reasoning.push(`<li>+${serviceScore}: Fulfills species service`);


            // 5) Production value
            const productionScore = analyzeProductionValue(building);
            analysis.score += productionScore;
            analysis.details.productionValue = productionScore;
            if (productionScore > 0) analysis.reasoning.push(`<li>+${productionScore}: High production value`);

            // 6) Prerequisite fulfillment
            const prereqScore = analyzeBuildingNeedsFulfilledByExisting(building, currentBuildings);
            analysis.score += prereqScore;
            if (prereqScore !== 0) {
                analysis.reasoning.push(`<li>+${prereqScore}: Inputs can be produced by existing buildings`);
            }
            analysis.details.prerequisiteFulfillment = prereqScore;

            // 7) Existing Building Recipe fulfillment
            const existingScore = analyzeExistingNeedsFulfilledByBuilding(building, currentBuildings);
            analysis.score += existingScore;
            if (existingScore !== 0) {
                analysis.reasoning.push(`<li>+${existingScore}: Outputs can be used by existing buildings`);
            }
            analysis.details.existingFulfillment = existingScore;

            // 8) Recipe / production bonus
            const recipeScore = analyzeRecipeBonus(building, currentBuildings);
            analysis.score += recipeScore;
            analysis.details.recipeBonus = recipeScore;
            if (recipeScore > 0) {
                analysis.reasoning.push(`<li>+${recipeScore}: Building contributes useful production`);
            }

            // 9) Rainwater bonus
            const rainwaterScore = analyzeRainwaterMatch(building, availableRainwater);
            analysis.score += rainwaterScore;
            analysis.details.rainwaterBonus = rainwaterScore;
            if (rainwaterScore > 0) {
                analysis.reasoning.push(`<li>+${rainwaterScore}: Available rainwater`);
            }

            // 10) Inherit bonus
            if (building.name == "Academy") {
                analysis.score += 20;
                analysis.reasoning.push(`<li>+20: Inherit bonus`);
            }
            if (building.name == "Bath House") {
                analysis.score += 20;
                analysis.reasoning.push(`<li>+20: Inherit bonus`);
            }
            if (building.name == "Clan Hall") {
                analysis.score += 30;
                analysis.reasoning.push(`<li>+30: Inherit bonus`);
            }
            if (building.name == "Feast Hall") {
                analysis.score += 10;
                analysis.reasoning.push(`<li>+10: Inherit bonus`);
            }
            if (building.name == "Forum") {
                analysis.score += 10;
                analysis.reasoning.push(`<li>+10: Inherit bonus`);
            }
            if (building.name == "Guild House") {
                analysis.score += 10;
                analysis.reasoning.push(`<li>+10: Inherit bonus`);
            }
            if (building.name == "Holy Guild House") {
                analysis.score += 20;
                analysis.reasoning.push(`<li>+20: Inherit bonus`);
            }
            if (building.name == "Holy Market") {
                analysis.score += 10;
                analysis.reasoning.push(`<li>+10: Inherit bonus`);
            }
            if (building.name == "Holy Temple") {
                analysis.score += 20;
                analysis.reasoning.push(`<li>+20: Inherit bonus`);
            }
            if (building.name == "Market") {
                analysis.score += 10;
                analysis.reasoning.push(`<li>+10: Inherit bonus`);
            }
            if (building.name == "Monastery") {
                analysis.score += 20;
                analysis.reasoning.push(`<li>+20: Inherit bonus`);
            }
            if (building.name == "Tavern") {
                analysis.score += 30;
                analysis.reasoning.push(`<li>+30: Inherit bonus`);
            }
            if (building.name == "Tea Doctor") {
                analysis.score += 0;
            }
            if (building.name == "Temple") {
                analysis.score += 0;
            }
            if (building.name == "Advanced Rain Collector") {
                analysis.score += 60;
                analysis.reasoning.push(`<li>+60: Inherit bonus`);

            };


            return analysis;
        }


        function analyzeResourceAvailability(building, biome) {
            let score = 0;

            // Normalize recipe list to an array of keys
            let recipeKeys = [];
            if (Array.isArray(building?.recipes)) {
                recipeKeys = building.recipes;
            } else if (building?.recipes && typeof building.recipes === 'object') {
                recipeKeys = Object.keys(building.recipes);
            }

            // If no recipes, return 0 score
            if (recipeKeys.length === 0) return score;

            // Normalize biome resources
            const abundant = Array.isArray(biome?.abundant_resources) ? biome.abundant_resources : [];
            const common = Array.isArray(biome?.common_resources) ? biome.common_resources : [];
            const rare = Array.isArray(biome?.rare_resources) ? biome.rare_resources : [];
            const nodes = Array.isArray(biome?.nodes) ? biome.nodes : [];

            recipeKeys.forEach(recipeKey => {
                let recipe = null;

                if (typeof recipeKey === "string") {
                    recipe = gameData.recipes?.[recipeKey];
                } else if (recipeKey && typeof recipeKey === "object" && recipeKey.name) {
                    recipe = gameData.recipes?.[recipeKey.name] || recipeKey;
                }

                if (building.category == "resource_acquisition")
                    if (nodes.includes(recipeKey)) {
                        score += 50;
                        return score
                    }

                if (building.category == "production") {
                    recipe.ingredients.forEach(ingredient => {
                        const options = Array.isArray(ingredient.options) ? ingredient.options : [];
                        if (options.length === 0) return;

                        if (options.some(r => abundant.includes(r))) score += 10;
                        if (options.some(r => common.includes(r))) score += 5;
                        if (options.every(r => rare.includes(r))) score += 2;
                    });
                }

            });

            return score;
        }




        function analyzeNeedsFulfillment(building, selectedSpecies) {
            let score = 0;
            const recipes = Array.isArray(building?.recipes) ? building.recipes : [];
            const needsFulfillment = {
                porridge: ['porridge'],
                biscuits: ['biscuits'],
                pie: ['pie'],
                jerky: ['jerky'],
                pickled_goods: ['pickled_goods'],
                skewers: ['skewers'],
                paste: ['paste'],
                coats: ['coats'],
                boots: ['boots'],
                religion: ['incense'],
                treatment: ['tea'],
                education: ['scrolls'],
                luxury: ['wine'],
                brawling: ['training_gear'],
                leisure: ['ale']
            };

            selectedSpecies.forEach(speciesKey => {
                const species = gameData.species[speciesKey];
                species?.needs?.forEach(need => {
                    const fulfillers = needsFulfillment[need];
                    if (!fulfillers) return;
                    recipes.forEach(recipeKey => {
                        const recipe = gameData.recipes[recipeKey];
                        if (recipe?.output && fulfillers.includes(recipe.output.item)) {
                            score += 20;
                        }
                    });
                });
            });

            return score;
        }

        function analyzeServiceFulfillment(building, selectedSpecies) {
            let score = 0;
            const serviceTypes = Array.isArray(building?.service_type) ? building.service_type : [];

            selectedSpecies.forEach(speciesKey => {
                const species = gameData.species[speciesKey];
                species?.needs?.forEach(need => {
                    if (serviceTypes.includes(need)) {
                        score += 20; // same score as before for fulfilling a need
                    }
                });
            });

            return score;
        }

        function analyzeProductionValue(building) {
            let score = 0;
            const recipes = Array.isArray(building?.recipes) ? building.recipes : [];
            const planks = ['planks'];
            const essential = ['bricks', 'fabric'];
            const tradable = ['pack_of_luxury_goods', 'pack_of_trade_goods'];
            const useful = ['tools', 'wildfire_essence', 'amber', 'pack_of_building_materials', 'pack_of_provisions', 'training_gear', 'parts', 'pipes'];
            const fuel = ['oil', 'coal'];

            recipes.forEach(recipeKey => {
                const recipe = gameData.recipes[recipeKey];
                const item = recipe?.output?.item;
                if (!item) return;

                if (planks.includes(item)) score += 50;
                else if (essential.includes(item)) score += 30;
                else if (tradable.includes(item)) score += 15;
                else if (useful.includes(item)) score += 10;
                else if (fuel.includes(item)) score += 5;

                // If you have recipe.stars, prefer that to key matching:
                // if (typeof recipe.stars === 'number') score += Math.max(0, recipe.stars - 1) * 3;
                if (recipeKey.includes('3star')) score += 10;
            });

            return score;
        }

        function analyzeBuildingNeedsFulfilledByExisting(newBuilding, currentBuildings) {
            let score = 0;
            let reasons = [];

            if (!newBuilding.recipes?.length) {
                return { score, reasons };
            }

            newBuilding.recipes.forEach(recipeKey => {
                const recipe = gameData.recipes?.[recipeKey];
                if (!recipe?.ingredients) return;

                recipe.ingredients.forEach(ingredient => {
                    const options = ingredient.options || [];

                    const canBeProduced = options.some(resource => {
                        return currentBuildings.some(buildingKey => {
                            const existing = gameData.buildings[buildingKey];
                            return existing?.recipes?.some(existingRecipeKey => {
                                const existingRecipe = gameData.recipes?.[existingRecipeKey];
                                return existingRecipe?.output?.item === resource;
                            });
                        });
                    });

                    if (canBeProduced) {
                        score += 5;
                        reasons.push(`Ingredient "${options.join(' or ')}" for new building can be produced by an existing building.`);
                    }
                });
            });

            return score;
        }


        function analyzeExistingNeedsFulfilledByBuilding(newBuilding, currentBuildings) {
            let score = 0;
            let reasons = [];

            if (!newBuilding.recipes?.length) {
                return { score, reasons };
            }

            // Gather outputs of the new building
            const newOutputs = newBuilding.recipes
                .map(rKey => gameData.recipes?.[rKey]?.output?.item)
                .filter(Boolean);

            currentBuildings.forEach(buildingKey => {
                const existing = gameData.buildings[buildingKey];
                if (!existing?.recipes) return;

                existing.recipes.forEach(recipeKey => {
                    const recipe = gameData.recipes?.[recipeKey];
                    if (!recipe?.ingredients) return;

                    recipe.ingredients.forEach(ingredient => {
                        const options = ingredient.options || [];

                        if (options.some(opt => newOutputs.includes(opt))) {
                            // Extra points if no other building currently produces this
                            const isCurrentlyBlocked = !currentBuildings.some(otherKey => {
                                if (otherKey === buildingKey) return false;
                                const otherBuilding = gameData.buildings[otherKey];
                                return otherBuilding?.recipes?.some(otherRecipeKey => {
                                    const otherOutput = gameData.recipes?.[otherRecipeKey]?.output?.item;
                                    return options.includes(otherOutput);
                                });
                            });

                            const points = isCurrentlyBlocked ? 8 : 5;
                            score += points;

                            reasons.push(
                                `Existing building "${buildingKey}" needs "${options.join(' or ')}" ` +
                                `which the new building can produce (${isCurrentlyBlocked ? 'currently blocked → +8' : '+5'})`
                            );
                        }
                    });
                });
            });

            return score;
        }


        function analyzeRecipeBonus(building, currentBuildings) {
            let score = 0;

            // All output items for THIS building
            const outputs = (building.recipes || [])
                .map(rKey => gameData.recipes[rKey]?.output?.item)
                .filter(Boolean); // remove null/undefined

            outputs.forEach(outputItem => {
                // Find highest star quality for this output in current buildings
                let maxStar = -1;

                currentBuildings.forEach(bKey => {
                    const b = gameData.buildings[bKey];
                    if (!b?.recipes) return;

                    b.recipes.forEach(rKey => {
                        const recipe = gameData.recipes[rKey];
                        if (recipe?.output?.item === outputItem) {
                            // Extract star rating from recipe key like "barrels_3star"
                            const starMatch = rKey.match(/(\d)star$/);
                            const stars = starMatch ? parseInt(starMatch[1], 10) : 1;
                            maxStar = Math.max(maxStar, stars);
                        }
                    });
                });

                // Compare against this building's star rating for that recipe
                const buildingStar = building.recipes.reduce((star, rKey) => {
                    const recipe = gameData.recipes[rKey];
                    if (recipe?.output?.item === outputItem) {
                        const starMatch = rKey.match(/(\d)star$/);
                        return Math.max(star, starMatch ? parseInt(starMatch[1], 10) : 1);
                    }
                    return star;
                }, 0);

                if (maxStar == -1) {
                    score += 20; // Can't produce this at all yet → big bonus
                } else if (buildingStar <= maxStar) {
                    score += -20; // Can already produce it
                } else {
                    score += 10; // Produces it better → medium bonus
                }
            });

            return score;

        }

        function analyzeRainwaterMatch(building, availableRainwater) {
            if (!building?.rain_engine) return 0;
            return availableRainwater.includes(building.rain_engine) ? 10 : 0;
        }

        function analyzeFertileSoilBonus(building, biome, currentBuildings) {
            let score = 0;

            // Determine fertile soil abundance multiplier
            let soilLevel = biome.fertile_soil?.[0] || "common";
            let soilMultiplier = 0;
            switch (soilLevel) {
                case "abundant": soilMultiplier = 1.5; break;
                case "common": soilMultiplier = 1.0; break;
                case "rare": soilMultiplier = 0.5; break;
            }


            score += 40 * soilMultiplier;
            return score
        }

        function isFarmWhileFarmingBuildingExists(building, biome, currentBuildings) {
            let score = 0;

            currentBuildings.forEach(bKey => {
                const cb = gameData.buildings[bKey];

                if (cb.category == "farming")
                    score -= 100
            })

            return score
        }

        function analyzeFertileSoilUsefulness(building, biome, currentBuildings) {

            let score = 0;
            // Check each "product_xstar" from the building's recipes
            building.recipes.forEach(rKey => {
                const match = rKey.match(/^(.+?)_(\d)star$/);
                if (!match) return;

                const product = match[1]; // e.g., "resin"
                const stars = parseInt(match[2], 10);

                // Check if this product is useful in existing buildings' recipes
                let usefulnessCount = 0;
                currentBuildings.forEach(bKey => {
                    const cb = gameData.buildings[bKey];
                    cb.recipes?.forEach(recipeKey => {
                        const recipe = gameData.recipes[recipeKey];
                        if (!recipe?.ingredients) return;

                        // Check all ingredient slots
                        recipe.ingredients.forEach(ingredient => {
                            if (ingredient.options?.includes(product)) {
                                usefulnessCount++;
                            }
                        });
                    });
                });

                if (usefulnessCount > 0) {
                    score += Math.ceil(20 * stars * Math.sqrt(usefulnessCount));
                }
            });

            return score;
        }


        // ==========================================
        // DISPLAY FUNCTIONS
        // ==========================================

        function displayResults(results) {
            const resultsContainer = document.getElementById('results');

            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="error">No valid blueprint options found.</div>';
                return;
            }

            const maxScore = Math.max(...results.map(r => r.score));

            let html = '';

            results.forEach((result, index) => {
                const building = gameData.buildings[result.building];
                const isBest = index === 0 && result.score > 0;
                const scoreClass = result.score >= maxScore * 0.8 ? 'best' :
                    result.score >= maxScore * 0.6 ? 'good' : 'poor';


                html += `
                                    <div class="recommendation ${isBest ? 'best' : ''}">
                                        <h3>${isBest ? '🏆 ' : ''}${building?.name || result.building} ${isBest ? '(Recommended)' : ''}</h3>
                                        <div class="score ${scoreClass}">Score: ${result.score.toFixed(1)}</div>
                                        <div class="reasoning">${result.reasoning.join('  ')}</div>
                                    </div>
                                `;
            });

            resultsContainer.innerHTML = html;
        }

        function showError(message) {
            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = `<div class="error">${message}</div>`;
        }
    </script>
    <script>
        src = "https://kit.fontawesome.com/c01fbeac04.js"
        crossorigin="anonymous"
    </script>
</body>
</html>